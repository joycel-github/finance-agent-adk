import logging
from google.adk.agents import LlmAgent, ParallelAgent, SequentialAgent
from google.adk.runners import Runner
from google.adk.events import Event
from google.adk.sessions import InMemorySessionService
from google.genai import types
from google.genai.types import GenerateContentConfig
from sub_agent.research.analysis_team.fundamental_agent import fundamental_agent
from sub_agent.research.analysis_team.technical_agent import technical_agent
from sub_agent.research.analysis_team.sentiment_agent import sentiment_agent
from sub_agent.research.analysis_team.risk_analysis_agent import risk_analysis_agent
from sub_agent.research.recommendation_team.equity_product_recommendation_agent import equity_products_recommendation
from sub_agent.research.writing_team.writing_agents import writer_agent, reviewer_agent, refactoring_agent, pdf_report_agent
from utils.pdf_generator import generate_pdf_report

# This is the main agent for stock analysis. We name this file as agent.py to easily use adk web for testing purpose for now.
analysis_initial_analysis_parallel_workflow = ParallelAgent(
    name="analysis_agents",
    description="Parallel agent for running all four analysis team agents",
    sub_agents=[
        fundamental_agent,
        technical_agent,
        sentiment_agent,
        risk_analysis_agent
    ]
)

merger_analysis_agent = LlmAgent(
    name="merger_analysis_agent",
    model="gemini-2.0-flash",
    description="An agent that merges the analysis generated by the analysis agents",
    instruction="""You are an AI Assistant responsible for combining research findings into a structured report.

Your primary task is to synthesize the following research summaries, clearly attributing findings to their source areas. Structure your response using headings for each topic. Ensure the report is coherent and integrates the key points smoothly.

**Crucially: Your entire response MUST be grounded *exclusively* on the information provided in the 'Input Summaries' below. Do NOT add any external knowledge, facts, or details not present in these specific summaries.**

**Input Summaries:**

*   **Fundamental Analysis:**
    {fundamental_analysis}

*   **Technical Analysis:**
    {technical_analysis}

*   **Sentiment Analysis:**
    {sentiment_analysis}

*   **Risk Analysis:**
    {risk_analysis}

**Output Format:**

## Summary of Stock Analysis

### Fundamental Analysis Findings
(Based on FundamentalAnalysisAgent's findings)
[Synthesize and elaborate *only* on the fundamental analysis input summary provided above.]

### Technical Analysis Findings
(Based on TechnicalAnalysisAgent's findings)
[Synthesize and elaborate *only* on the technical analysis input summary provided above.]

### Sentiment Analysis Findings
(Based on SentimentAnalysisAgent's findings)
[Synthesize and elaborate *only* on the sentiment analysis input summary provided above.]

### Risk Analysis Findings
(Based on RiskAnalysisAgent's findings)
[Synthesize and elaborate *only* on the risk analysis input summary provided above.]

### Overall Conclusion
[Provide a brief (1-2 sentence) concluding statement that connects *only* the findings presented above.]

Output *only* the structured report following this format. Do not include introductory or concluding phrases outside this structure, and strictly adhere to using only the provided input summary content.
""",
    output_key="merged_analysis"
)


writing_workflow = SequentialAgent(
    name="writing_team",
    description="Sequential agent that writes a report based on the merged_analysis and the equity_products_recommendation",
    sub_agents=[
        writer_agent,
        reviewer_agent,
        refactoring_agent,
        pdf_report_agent
       
    ]
)

e2e_workflow = SequentialAgent(
    name="sequential_agent",
    description="""Sequential agent that 
    1. first run all 4 analysis agents in parallel 
    2. run the merger_analysis_agent to merge the data 
    3. run the stock recommendation agent based on the merged_analysis
    4. run the writing team to write the final report
    """,
    sub_agents=[
        analysis_initial_analysis_parallel_workflow,
        merger_analysis_agent,
        equity_products_recommendation,
        writing_workflow
    ]
)

root_agent = e2e_workflow


# uncomment this to run the agent locally
# Configure logging
# logging.basicConfig(level=logging.INFO)
# logger = logging.getLogger(__name__)

# async def call_agent_async(query: str, runner, user_id, session_id, session):
#     researcher_names = [
#         "fundamental_analysis_agent",
#         "technical_analysis_agent",
#         "sentiment_analysis_agent",
#         "risk_analysis_agent"
#     ]
#     writer_agent_names = [
#         "writer_agent",
#         "reviewer_agent",
#         "refactoring_agent"
#     ]
#     researcher_outputs = {}
#     merger_agent_name = "merger_analysis_agent"
#     equity_products_recommendation_name = "equity_products_recommendation"
#     print(f"\n>>> User Query: {query}")
#     content = types.Content(role='user', parts=[types.Part(text=query)])
#     final_response_text = "Agent did not produce a final response."
#     print("Starting pipeline...")
#     try:
#         async for event in runner.run_async(
#             user_id=user_id, session_id=session_id, new_message=content
#         ):
#             author_name = event.author or "System"
#             is_final = event.is_final_response()
#             print(f"  [Event] From: {author_name}, Final: {is_final}")

#             if is_final and author_name in researcher_names and event.content and event.content.parts:
#                 researcher_output = event.content.parts[0].text.strip()
#                 if author_name not in researcher_outputs:
#                     print(f"    -> Intermediate Result from {author_name}: {researcher_output}")
#                     researcher_outputs[author_name] = researcher_output

#             elif is_final and author_name == merger_agent_name and event.content and event.content.parts:
#                 merged_analysis = event.content.parts[0].text.strip()
#                 print(f"\n<<< Merged Analysis (from {author_name}):\n{merged_analysis}")

#             elif is_final and author_name == equity_products_recommendation_name and event.content and event.content.parts:
#                 final_response_text = event.content.parts[0].text.strip()
#                 print(f"\n<<< Final Stock Recommendation (from {author_name}):\n{final_response_text}")

#             elif is_final and author_name in writer_agent_names and event.content and event.content.parts:
#                 final_response_text = event.content.parts[0].text.strip()
#                 print(f"\n<<< Final Report (from {author_name}):\n{final_response_text}")

#             elif hasattr(event, "error_message") and event.error_message:
#                 print(f"  -> Error from {author_name}: {event.error_message}")

#         if final_response_text == "Agent did not produce a final response.":
#             print("<<< Pipeline finished but did not produce the expected final text response from the StockRecommendationAgent.")

#     except Exception as e:
#         print(f"\n❌ An error occurred during agent execution: {e}")

#     print(f"\nFinal Session state: {session.state}")


# async def run_parallel_agent():
#     session_service = InMemorySessionService()
#     APP_NAME = "scratch_app"
#     USER_ID = "user_1"
#     SESSION_ID = "session_001"

#     session = await session_service.create_session(
#         app_name=APP_NAME,
#         user_id=USER_ID,
#         session_id=SESSION_ID
#     )
#     print(f"Session created: App='{APP_NAME}', User='{USER_ID}', Session='{SESSION_ID}'")

#     runner = Runner(
#         agent=root_agent,
#         app_name=APP_NAME,
#         session_service=session_service
#     )
    
#     print(f"Runner created for agent '{runner.agent.name}'.")

#     # Use the new interaction function
#     await call_agent_async("analyze microsoft and tell me whether we should buy the stock or not", runner, USER_ID, SESSION_ID, session)


# if __name__ == "__main__":
#     asyncio.run(run_parallel_agent())


